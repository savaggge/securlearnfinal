3. РЕАЛИЗАЦИЯ СИСТЕМЫ
В данном разделе представлено описание процесса реализации функциональных компонентов системы, включая разработку пользовательского интерфейса и логики работы микросервисов. Основное внимание уделено ключевым аспектам функционирования онлайн-магазина фармацевтической продукции, таким как оформление заказов, работа с корзиной, авторизация пользователей, управление товарами и интеграция со складскими остатками.
Приведены основные инструменты, технологии и библиотеки, использованные в ходе разработки. Также обоснованы архитектурные и структурные решения, принятые в процессе реализации программного обеспечения.

Реализация системы выполнена с использованием современных подходов, что позволило обеспечить масштабируемость, безопасность и стабильность приложения.

3.1 Инструменты разработки
Разработка системы была выполнена с применением технологий платформы .NET 9 и языка программирования C#, что позволило построить устойчивую серверную часть, работающую в рамках микросервисной архитектуры.
Для хранения и управления данными используется Microsoft SQL Server, каждая служба подключается к своей базе данных с помощью Entity Framework Core, реализованного по принципу Code First.
ASP.NET Core Web API используется для создания REST-интерфейсов, через которые происходит взаимодействие между микросервисами и с фронтендом. Для обработки JSON используется библиотека System.Text.Json.
Для разделения слоёв и организации кода применена Clean Architecture. В рамках проекта логика каждого микросервиса разделена на следующие слои: Core (модели, интерфейсы, DTO и сервисы), Infrastructure (реализация доступа к данным и репозитории) и API (контроллеры и точки входа в систему).
Аутентификация и авторизация реализованы с использованием ASP.NET Core Identity, что позволило надёжно управлять ролями и правами доступа пользователей. Хранение паролей и чувствительной информации осуществляется с хэшированием. Для доступа к защищённым ресурсам используется JWT (JSON Web Token) — токены выдаются после входа в систему и прикрепляются к последующим запросам. Это обеспечивает безопасную и масштабируемую авторизацию во взаимодействии между микросервисами и клиентской частью.
Для реализации клиентской части (интерфейса пользователя) использован ASP.NET Core MVC. HTML и Razor используются для представлений, Bootstrap — для адаптивной верстки и UI, jQuery — для обработки событий и AJAX-запросов.
Проект разрабатывался в среде Microsoft Visual Studio 2022, обеспечивающей удобную навигацию, отладку и управление зависимостями. Docker использовался для контейнеризации микросервисов, а взаимодействие между ними — через HTTP-запросы внутри Docker-сети.

Визуализация структуры файлов и компонентов системы приведена на рисунке 3.1.
 
Рисунок 3.1 – Интегрированная среда разработки Visual Studio 

3.2 Основные библиотеки и технологии, используемые в системе
Серверная часть (.NET и работа с данными):
	ASP.NET Core
	Entity Framework Core
	Microsoft SQL Server
	AutoMapper
	System.Text.Json
	FluentValidation

Аутентификация и безопасность:
	ASP.NET Core Identity
	JWT (System.IdentityModel.Tokens.Jwt)
	Microsoft.AspNetCore.Authentication.JwtBearer

Контейнеризация и взаимодействие микросервисов:
	Docker
	Docker Compose
	HttpClientFactory

Интерфейс пользователя:
	ASP.NET Core MVC
	Bootstrap
	jQuery
В процессе реализации системы использовались актуальные версии библиотек и NuGet-пакетов, необходимых для работы с базой данных, валидации данных, маппинга моделей и построения API. Установка и настройка зависимостей производились через встроенный пакетный менеджер в среде разработки Visual Studio 2022.
 
Рисунок 3.2 – Установленные NuGet-пакеты, используемые в проекте

На рисунке представлены основные библиотеки, используемые в проекте:
	AutoMapper — для маппинга объектов между слоями;
	FluentValidation.AspNetCore — для удобной и расширяемой валидации моделей;
	Microsoft.EntityFrameworkCore, Design, SqlServer — для взаимодействия с базой данных через ORM Entity Framework Core, включая поддержку SQL Server и миграций.


3.3 Реализация микросервисов
Каждый микросервис в системе реализует строго определённую бизнес-функцию и взаимодействует с другими сервисами исключительно через REST API. Такой подход позволяет обеспечивать слабую связность между компонентами, упрощает масштабирование и сопровождение проекта.
Микросервисы построены на единой архитектурной основе с соблюдением принципов Clean Architecture и использованием одинаковых подходов к структуре проекта, DI, логике авторизации и доступу к данным.
Ниже приведено описание реализации основных микросервисов системы, включая их структуру, особенности взаимодействия и используемые компоненты.


3.3.1 ProductMicroservice
ProductMicroservice отвечает за управление товарами и их категоризацию. Он предоставляет API для создания, редактирования, удаления и получения информации о продуктах и категориях.
Микросервис реализован с применением шаблона Clean Architecture:
	Core содержит модели Product, Category, ProductCategory, DTO-объекты, интерфейсы репозиториев и сервисов.
	Infrastructure реализует репозитории и конфигурации EF Core для соответствующих сущностей.
	API включает контроллеры ProductsController и CategoriesController, обрабатывающие входящие HTTP-запросы.
Взаимодействие с другими сервисами осуществляется через HTTP-запросы. Для обработки входных данных используется FluentValidation, а преобразование между сущностями и DTO реализовано через AutoMapper.
Хранение данных осуществляется в отдельной базе Microsoft SQL Server, структура которой формируется с использованием миграций EF Core по подходу Code First. Каждая запись в таблице продуктов содержит информацию о названии, описании, цене, производителе, сроке годности и других фармацевтических характеристиках.
Контроллеры обеспечивают стандартные CRUD-операции:
	/api/Products — создание, получение, обновление, удаление товаров;
	/api/Categories — работа с категориями товаров.
Аутентификация пользователей при доступе к API осуществляется через JWT-токены, проверяемые на уровне middleware.
Таким образом, ProductMicroservice является ключевым компонентом системы, обеспечивающим основу для формирования товарного каталога, взаимодействия с корзиной, заказами и складами.

3.3.2 UsersMicroservice
UsersMicroservice отвечает за регистрацию, аутентификацию, авторизацию и управление учётными записями пользователей. Он реализован на базе ASP.NET Core Identity с расширенной моделью пользователя и поддержкой JWT-аутентификации.
Архитектура микросервиса построена по принципам Clean Architecture:
	Core включает модели ApplicationUser, ApplicationUserRole, DTO и интерфейсы сервисов;
	Infrastructure содержит реализацию репозиториев и конфигурации Identity;
	API реализует контроллеры AuthController, AccountController, UsersController, обслуживающие запросы пользователей.
Для авторизации используется JWT: после регистрации или входа пользователю выдаётся токен, который затем используется в заголовках запросов. Пароли сохраняются в хэшированном виде.
Контроллеры UsersMicroservice реализуют следующие функции (см. Swagger-интерфейс):
	/api/Auth/register и /api/Auth/login — регистрация и вход в систему;
	/api/Account/update, /change-password, /delete — управление профилем пользователя;
	/api/Users — просмотр и управление пользователями, фильтрация, поиск по email и id.
Система ролей реализована через IdentityRole. В проекте используются роли:
	Admin — полный доступ ко всем функциям;
	Manager — управление товарами, заказами, уведомлениями;
	User — доступ к заказам, корзине, профилю;
	Гость — неавторизованный пользователь с минимальным доступом.
Слой сервисов инкапсулирует логику работы с Identity, а слой репозиториев — взаимодействие с контекстом данных IdentityDbContext. Все контроллеры защищены с помощью атрибутов [Authorize] и проверкой прав доступа по ролям.
Таким образом, UsersMicroservice играет ключевую роль в обеспечении безопасности и разграничения доступа во всей системе.

3.3.3 CartMicroservice
CartMicroservice реализует логику пользовательской корзины, предоставляя интерфейс для временного хранения выбранных товаров до оформления заказа. Основной задачей микросервиса является обработка добавления, удаления и изменения количества товаров в корзине, а также передача содержимого корзины в OrdersMicroservice при оформлении покупки.
Микросервис построен по шаблону Clean Architecture:
	Core содержит модели Cart, CartItem, DTO и сервисные интерфейсы;
	Infrastructure отвечает за хранение данных и реализацию репозиториев;
	API включает контроллер CartController, реализующий REST-интерфейс для взаимодействия с корзиной.
Для хранения данных CartMicroservice использует Redis, обеспечивающий быструю работу с временными пользовательскими данными. Это особенно актуально для корзины, где высокая скорость доступа важна для отзывчивости интерфейса.
Микросервис предоставляет следующие операции :
	/api/Cart — получить содержимое корзины;
	/api/Cart/add, /addQuantity, /decreaseQuantity — добавление и изменение количества товара;
	/api/Cart/delete/{productId} — удаление позиции из корзины;
	/api/Cart/clear — очистка корзины;
	/api/Cart/checkout — передача данных в OrdersMicroservice.
Все операции защищены JWT-аутентификацией для зарегистрированных пользователей. Однако также предусмотрена возможность создания корзины для неавторизованных пользователей (гостей) — данные временно сохраняются в Redis и ассоциируются с уникальным идентификатором сессии, что обеспечивает доступность функциональности корзины до момента регистрации или входа.
Для каждого пользователя или гостя корзина создаётся индивидуально. Логика расчёта итоговой стоимости корзины инкапсулирована в сервисный слой.
Таким образом, CartMicroservice реализует ключевой элемент взаимодействия пользователя с системой и обеспечивает высокую производительность за счёт использования Redis и отказа от традиционного хранения корзины в SQL-базе.

3.3.4 OrdersMicroservice
OrdersMicroservice отвечает за оформление, хранение и обработку заказов пользователей, включая состав заказа, статус, стоимость, данные о доставке и интеграцию с системой онлайн-оплаты. Этот микросервис играет центральную роль в процессе завершения покупки и обеспечивает надёжность всего цикла заказа.
Микросервис реализован с соблюдением принципов Clean Architecture:
	Core содержит модели Order, OrderItem, ShippingDetails, DTO и интерфейсы сервисов;
	Infrastructure реализует репозитории, миграции и конфигурации базы данных;
	API включает контроллер OrdersController для обработки заказов и StripeController для работы с платёжной системой.
Данные о заказах хранятся в базе данных Microsoft SQL Server. Каждая сущность Order связана с пользователем и содержит список позиций заказа (OrderItem) и объект доставки (ShippingDetails).
Микросервис предоставляет следующие операции:
	/api/Orders — создание и получение всех заказов;
	/api/Orders/{orderId} — получение, обновление и удаление заказа по ID;
	/api/Orders/userId/{userId} — получение заказов конкретного пользователя;
	/api/Orders/filter-sort — фильтрация и сортировка заказов;
	/api/Stripe/webhook — приём уведомлений от платёжной системы Stripe.
Интеграция с системой оплаты
Оплата заказов реализована через подключение к Stripe. После подтверждения платежа с помощью Webhook обновляется статус заказа. Это позволяет автоматически отслеживать успешные транзакции и обеспечивает защиту от подделки запросов благодаря валидации подписи события.
JWT-аутентификация применяется для обеспечения безопасности доступа к API. Все запросы к заказам пользователя проверяются на соответствие авторизованному ID.
OrdersMicroservice взаимодействует с CartMicroservice (при оформлении заказа), WarehouseMicroservice (проверка наличия и списание товаров) и NotificationMicroservice (отправка уведомлений о заказе).
Таким образом, OrdersMicroservice является ключевым звеном в цепочке продаж, обеспечивая полный цикл от оформления до подтверждения и хранения заказа.

3.3.5 WarehouseMicroservice
WarehouseMicroservice реализует логику управления складами и учётом остатков товаров. Микросервис предоставляет интерфейс для добавления, редактирования, удаления складов, а также для отслеживания количества конкретных товаров на каждом складе. Это позволяет централизованно контролировать наличие продукции и корректно обрабатывать заказы.
Микросервис построен по шаблону Clean Architecture:
	Core включает модели Warehouse, WarehouseProduct, DTO и интерфейсы сервисов;
	Infrastructure реализует репозитории и конфигурации Entity Framework Core для взаимодействия с базой данных;
	API содержит контроллер WarehousesController, предоставляющий REST-интерфейс для всех операций.
Данные хранятся в отдельной базе MSSQL. Каждому складу соответствует отдельная запись, а учёт остатков ведётся через сущность WarehouseProduct, отражающую количество конкретного товара на конкретном складе.
Основные операции микросервиса:
	/api/Warehouses — получение всех складов;
	/api/Warehouses/{id} — получение склада по идентификатору;
	Добавление и редактирование склада (методы AddWarehouse, UpdateWarehouse);
	Удаление склада (DeleteWarehouse);
	Получение складов по фильтру (GetWarehousesByCondition);
	Добавление или обновление информации о товаре на складе (AddOrUpdateProductInWarehouse);
	Удаление товара со склада (DeleteProductFromWarehouse);
	Получение всех товаров на складе (GetProductsByWarehouse);
	Получение общей информации о товаре со всех складов (GetProductStockFromAllWarehouses).
API защищён JWT-аутентификацией, и доступ к операциям предоставляется только пользователям с соответствующими правами (роли Manager или Admin).
Микросервис активно взаимодействует с OrdersMicroservice (для проверки и списания остатков при оформлении заказа) и с ProductMicroservice (для получения сведений о товарах).
Таким образом, WarehouseMicroservice является важной частью системы, отвечающей за точность остатков и готовность к отгрузке товаров.

3.3.6 NotificationMicroservice
NotificationMicroservice отвечает за хранение и отправку уведомлений пользователям системы. Основная задача микросервиса — формирование и передача сообщений (например, об успешной регистрации, оплате, оформлении заказа и т. д.) по указанному адресу электронной почты. Микросервис не имеет прямой связи с другими микросервисами, взаимодействие осуществляется исключительно через HTTP-запросы.
Архитектура реализована по принципам Clean Architecture:
	Core содержит модель Notification, DTO (NotificationRequest, NotificationResponse) и интерфейс INotificationsService;
	Infrastructure включает реализацию отправки писем, хранение уведомлений и конфигурацию подключения;
	API реализует контроллер NotificationController, принимающий входящие запросы на отправку и получение уведомлений.
Для хранения данных используется база данных Microsoft SQL Server. Все отправленные уведомления записываются в таблицу, что позволяет при необходимости просматривать историю уведомлений.
Интерфейс INotificationsService реализует следующие методы:
	SendEmail(NotificationRequest request) — отправка письма на указанный email;
	GetNotificationById(Guid id) — получение уведомления по идентификатору;
	GetCategories() — получение списка всех отправленных уведомлений (например, для логов или административной панели).
Отправка email реализована через SMTP-сервер, настройки которого задаются в конфигурации. Для безопасной передачи и настройки сервиса используются стандартные механизмы ASP.NET Core.

3.4 Подключение и работа с базами данных
Каждый микросервис системы подключается к своей базе данных, реализованной в среде Microsoft SQL Server, с использованием Entity Framework Core и подхода Code First. Это позволяет генерировать структуру базы непосредственно из кода, управлять миграциями и обеспечивать полную синхронизацию между моделью и хранилищем данных.
Для хранения строк подключения используется файл appsettings.json, где через ключ ConnectionStrings задаются параметры подключения к каждой БД. Пример конфигурации приведён на рисунке В.1.
Подключение к базе выполняется в инфраструктурном слое каждого микросервиса. Через метод AddDbContext<TContext>() задаётся конкретный тип контекста и подключение по имени строки из конфигурации. Это показано на рисунке В.2.
В микросервисе UsersMicroservice используется специализированный контекст ApplicationDbContext, который наследуется от IdentityDbContext. Это позволяет интегрировать в систему ASP.NET Core Identity и управлять пользователями, ролями, хэшированием паролей и другими аспектами безопасности. Пример реализации приведён на рисунке В.3.
Настройка Identity и регистрация служб Identity в контейнере зависимостей осуществляется через метод AddIdentity, где также задаются параметры политики безопасности паролей. Всё это сопровождается регистрацией хранилищ (AddUserStore, AddRoleStore и т.д.). Иллюстрация конфигурации приведена на рисунке В.4.
Контексты, не использующие Identity (например, в ProductMicroservice), наследуются от базового DbContext и определяют через DbSet<T> таблицы базы. Пример структуры такого контекста показан на рисунке В.5.
Микросервис Cart использует в качестве хранилища Redis, благодаря чему данные корзины быстро доступны и не загружают основную БД. В качестве интерфейса взаимодействия используется IDistributedCache, внедряемый в CartRepository через DI-контейнер. Пример такой реализации — на рисунке В.6.
Таким образом, каждая часть системы надёжно интегрирована с собственной базой данных с помощью Entity Framework Core и, при необходимости, IdentityDbContext. Выбранный подход обеспечивает как безопасность хранения данных, так и гибкость при расширении функционала.
Следующим важным аспектом проектирования и реализации системы является организация доступа к данным и внедрение зависимостей. Эти элементы напрямую влияют на читаемость кода, тестируемость компонентов и модульность архитектуры.
 
3.5 Слой репозиториев и внедрение зависимостей.
Согласно принципам Clean Architecture, доступ к данным в каждом микросервисе реализуется через слой репозиториев. Это обеспечивает изоляцию бизнес-логики от конкретной реализации источника данных и делает систему гибкой и тестируемой.
Каждый репозиторий реализует интерфейс, определённый в слое Core. Например, в WarehouseMicroservice используется интерфейс IWarehouseRepository, реализуемый классом WarehouseRepository в слое Infrastructure.
Пример внедрения зависимости репозитория представлен на рисунке В.2. Здесь в классе DependencyInjection происходит регистрация зависимостей через метод расширения AddInfrastructure, где с помощью метода AddScoped добавляется сопоставление интерфейса и реализации.
Дополнительно в этом же методе происходит регистрация контекста базы данных через AddDbContext, с использованием строки подключения из appsettings.json.
Во всех микросервисах используется единая схема DI (Dependency Injection), встроенная в ASP.NET Core через IServiceCollection. Это позволяет централизованно настраивать все зависимости и упрощает модульное тестирование.
На рисунке Г.1 представлен интерфейс IOrdersRepository, определяющий контракт для работы с сущностями заказов. Интерфейс включает основные методы:
	добавление, обновление и удаление заказов (AddOrderAsync, UpdateOrderAsync, DeleteOrderAsync);
	выборка по идентификатору (GetOrderByIdAsync);
	получение всех заказов и фильтрация по пользователю (GetOrdersAsync, GetOrdersByUserIdAsync);
	получение запроса в виде IQueryable для построения динамических фильтров (GetQueryableOrders).
Реализация интерфейса, представленная на рисунке Г.2, осуществляется в классе OrdersRepository. Для взаимодействия с базой данных используется контекст ApplicationDbContext, внедряемый через конструктор. Таким образом, обеспечивается единообразная и централизованная работа с данными, а бизнес-логика остаётся чистой от инфраструктурных зависимостей.

В CartMicroservice реализован пример внедрения зависимостей с использованием Redis. Репозиторий CartRepository зависит от IDistributedCache, которая внедряется автоматически через DI-контейнер ASP.NET Core (см. рисунок В.3). Это позволяет использовать Redis как хранилище временных данных без привязки к конкретной реализации.

Примеры подключения и конфигурации зависимостей можно увидеть на следующих изображениях:
	Рисунок В.1 – Конфигурация строки подключения к базе данных в appsettings.json;
	Рисунок В.2 – Регистрация контекста и репозиториев в методе AddInfrastructure;
	Рисунок В.3 – Пример внедрения кэша Redis в CartRepository.

Такой подход позволяет:
	поддерживать слабую связанность между компонентами;
	упростить модульное тестирование;
	повысить читаемость и расширяемость системы;
	реализовать принцип инверсии зависимостей (Dependency Inversion Principle) в соответствии с SOLID.

Таким образом, слой репозиториев и система внедрения зависимостей формируют основу взаимодействия бизнес-логики и источников данных, обеспечивая масштабируемость и поддержку единых архитектурных принципов во всех микросервисах системы.

3.6 Слой сервисов
Сервисный слой в архитектуре системы играет роль посредника между контроллерами (веб-слоем) и репозиториями (данными). Он инкапсулирует бизнес-логику и обеспечивает централизованную обработку входных данных, валидацию, преобразование DTO и взаимодействие с репозиториями.
Каждый сервис реализует заранее определённый интерфейс, зарегистрированный в слое Core. Это способствует соблюдению принципов инверсии зависимостей (D — из SOLID) и облегчает написание модульных тестов.
На рисунке З.3 представлен интерфейс ICategoriesService, реализующий методы для управления категориями:  
Рисунок 3.3 - Интерфейс ICategoriesService

	Добавление новой категории (AddCategory);
	Обновление и удаление;
	Получение одной или всех категорий.
Реализация интерфейса выполняется в классе CategoriesService, показанном на рисунке З.4. 
 
Рисунок 3.4 - Класс CategoriesService

Внедрение зависимостей осуществляется через конструктор, где сервис получает:
	ICategoriesRepository — для работы с данными категорий;
	IProductsRepository — для проверки логических связей (например, при удалении категории);
	IMapper — для преобразования между DTO и сущностями.
Метод AddCategory иллюстрирует типичный подход: сначала проверяются входные данные, затем они преобразуются в сущность Category, присваивается новый идентификатор, и объект передаётся в репозиторий для сохранения.
Такой подход:
	Обеспечивает чёткое разграничение ответственности;
	Позволяет повторно использовать бизнес-логику в разных контроллерах;
	Повышает читаемость и поддерживаемость кода.
Реализация всех сервисов в проекте следует аналогичной структуре: интерфейс (контракт) находится в слое Core, реализация — в Application, зависимости внедряются через конструктор с использованием DI-контейнера ASP.NET Core.
Особое внимание в рамках реализации системы уделено организации аутентификации и авторизации пользователей, которая была построена на базе ASP.NET Core Identity. Подробнее об этом — в следующем разделе.


3.7 Пользовательская система и роли (ASP.NET Identity)
Пользовательская аутентификация и авторизация реализованы на базе ASP.NET Core Identity, которая была расширена с учётом требований проекта.
Для представления пользователей используется модель ApplicationUser, наследуемая от IdentityUser<Guid>. Она дополнена полями: FirstName, LastName, PostalCode, Country и др. (см. рисунок Е.1). Аналогично, роли реализуются через ApplicationRole, основанный на IdentityRole<Guid> (рисунок Е.2).
Настройка Identity происходит в слое Infrastructure, где сервисы UserStore, RoleStore и DbContext регистрируются в DI-контейнере с помощью метода AddIdentity (рисунок Е.3). Для упрощённого доступа к API и минимальных требований к паролям установлены соответствующие опции.
Роли в системе:
•	Admin — полный доступ к системе;
•	Manager — управление товарами, заказами, складами;
•	User — оформляет заказы, управляет профилем;
•	Гость — может просматривать каталог, но не оформлять заказы.
Работа с пользователями осуществляется через UserManager, SignInManager и IJwtService. Все зависимости внедряются через конструктор в UsersService (рисунок Е.4).
JWT-аутентификация
После входа пользователя с помощью SignInManager генерируется JWT-токен через JwtService. Его реализация основана на классе JwtSecurityToken, в который добавляются основные claims: NameIdentifier, Jti, Iat, Role и др. (см. приложение Д — фрагмент кода JwtService.cs). Далее токен возвращается клиенту и используется для авторизации последующих запросов.
Конфигурация JWT-аутентификации и авторизации реализована в Program.cs с помощью middleware AddAuthentication и AddAuthorizationBuilder, где настроены правила валидации токенов и политики доступа по ролям (рисунок Е.5).
Таким образом, реализованная система позволяет безопасно управлять пользователями, разграничивать доступ к ресурсам на основе ролей и использовать стандартные механизмы ASP.NET Identity в рамках микросервисной архитектуры.

3.8 Тестирование и отладка микросервисов
В процессе разработки системы была проведена начальная проверка работоспособности REST API и корректности взаимодействия микросервисов. Для этого использовались следующие инструменты:
	Swagger (Swashbuckle)
Каждый микросервис содержит встроенную документацию API на основе Swagger. Это позволило быстро проверять доступные маршруты, передавать параметры и анализировать ответы от контроллеров без необходимости использования внешних клиентов.

Для удобного тестирования и визуализации доступных HTTP-эндпоинтов был использован встроенный инструмент Swagger UI, автоматически сгенерированный на основе аннотаций контроллеров ASP.NET Core. Это позволило быстро проверять работу микросервисов без написания внешних запросов.
 
Рисунок 3.5 – Swagger-интерфейс микросервиса ProductsService

На изображении представлена документация и интерфейс тестирования API микросервиса, отвечающего за управление товарами и категориями. Интерфейс включает стандартные HTTP-методы (GET, POST, PUT, DELETE) для работы с ресурсами /api/Products и /api/Categories, обеспечивая полный CRUD-функционал.
Каждый метод можно протестировать прямо из браузера, задав параметры, тело запроса и просматривая ответ от сервера в режиме реального времени.

	Postman
	Для более гибкого тестирования API использовался Postman. Он позволил создавать коллекции запросов, передавать заголовки, тело запросов и JWT-токены, что было особенно полезно при тестировании защищённых эндпоинтов и взаимодействия между микросервисами.

 
Рисунок 3.6 – Запрос на получение списка товаров через Postman

На изображении показан результат выполнения GET-запроса к эндпоинту /api/products/ с помощью инструмента Postman. В ответ возвращается список товаров в формате JSON, включая поля id, name, description, price, imageUrl и связанные productCategories. Код ответа 200 OK подтверждает успешную обработку запроса.

С помощью этих инструментов была протестирована работа ключевых сценариев: авторизация пользователя, добавление товаров, оформление заказа, взаимодействие с корзиной, а также обработка ошибок и валидация данных.

Тестирование позволило убедиться в корректной работе API, надёжности передачи данных и соответствии реализованных функций заявленным требованиям.
 
3.9 Тестирование системы
Тестирование информационной системы — важный этап разработки, направленный на проверку корректности работы, устойчивости и соответствия заявленным требованиям. Его основная цель — убедиться в том, что система работает стабильно, безопасно и выполняет все предусмотренные функции до этапа её внедрения.

Функциональное тестирование проводится для оценки правильности работы ключевых компонентов системы: от аутентификации до обработки пользовательских данных и взаимодействия с базой. Для этого создаются тестовые сценарии, охватывающие типовые и пограничные случаи использования, а также автоматизированные проверки.

В дополнение выполняется проверка на безопасность, тестирование под нагрузкой и анализ удобства пользовательского взаимодействия. Эти этапы помогают убедиться в защищённости системы, её отклике под высокой нагрузкой и удобстве для конечного пользователя.

Итоговые данные по функциональному тестированию приведены в таблице 3.1. 
Она включает перечень сценариев, ожидаемые и фактические результаты проверки.
Таблица 3.1 – Функциональное тестирование системы
№	Сценарий	Ожидаемый исход	Результат
1	Регистрация пользователя	Успешный вход в систему и генерация токена.	Успех
2	Добавление товара администратором в панели товаров	Товар добавлен в базу данных	Успех
3	Оформление заказа зарегистрированным пользователем	Добавление заказа в базу данных	Успех
4	Добавление товара в корзину	Если товар уже существует- инкрементация количества товара, если нет  – добавить товар как новый	Успех


Таким образом, в ходе реализации были последовательно разработаны все микросервисы системы, организованы базы данных, внедрены репозитории и сервисы, обеспечено взаимодействие через REST API, а также реализованы механизмы безопасности, хранения корзины в Redis и система ролей с использованием ASP.NET Identity. Все архитектурные и технологические решения были направлены на создание масштабируемой, надёжной и удобной платформы для продажи фармацевтической продукции.
На следующем этапе представлено руководство пользователя, описывающее работу с системой с точки зрения конечного пользователя.
